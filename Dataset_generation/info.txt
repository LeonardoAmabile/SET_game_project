The main task of this section in to create the dataset for the NN in the case of n cards (see Read.me).
 
----------------------------------------------------------
### Table.cpp file ###
----------------------------------------------------------
This code defines the `Table` class and associated methods for handling a table of data represented as a 2D vector. It supports both automatic generation of random data and the ability to manually define the data. The class also provides various methods for accessing and manipulating the data.

1. **Custom Hash Function for `vector<int>` (VectorHash)**
   - The `VectorHash` struct is defined with an overloaded `operator()` that provides a custom hash function for vectors of integers.
   - The hash function converts the values in the vector into ternary digits:
     - `-1` is converted to `0`,
     - `0` is converted to `1`, and
     - `1` is converted to `2`.
   - The resulting values are then used to compute the hash using base 3 arithmetic.

2. **Constructor for Random Data Generation (`Table::Table(int numCards, int numAttributes)`)**
   - This constructor initializes the table with randomly generated data. The number of cards (rows) is specified by `numCards`, and the number of attributes (columns) is specified by `numAttributes`.
   - A check is performed to ensure that the number of cards does not exceed the maximum possible unique combinations (`3^numAttributes`). If the number of cards exceeds this limit, an exception is thrown.
   - The constructor uses a random number generator to create rows with values `-1`, `0`, or `1`, ensuring that each row is unique by storing them in an `unordered_set`.
   - Once the required number of unique rows is generated, they are assigned to the `tableData` member variable.

3. **Constructor for Manual Data Initialization (`Table::Table(const vector<vector<int>>& manualData)`)**
   - This constructor allows initializing the table with manually provided data (2D vector).
   - The `tableData` member variable is assigned the provided data, and the constructor verifies that all rows have the same number of columns. If any row has a different number of columns, an exception is thrown.

4. **Method to Get a Value at a Specific Row and Column (`Table::getValue(int row, int column) const`)**
   - This method retrieves the value from the table at the specified `row` and `column`.
   - If the provided row and column indices are valid, the method returns the value at the corresponding location in the `tableData` matrix.
   - If the indices are out of bounds, an `out_of_range` exception is thrown.

5. **Method to Print the Entire Table (`Table::printTable() const`)**
   - This method prints the entire table, row by row.
   - It iterates over each row and prints the values in that row, followed by a new line.

6. **Method to Get the Table as a Matrix (`Table::getMatrix() const`)**
   - This method returns the table's data as a 2D vector (`tableData`), which is useful for manipulating or accessing the raw table data.

7. **Method to Print a Specific Row by Its Index (`Table::print_row(int rowidx) const`)**
   - This method prints the row at the specified index `rowidx`.
   - It checks if the index is valid and prints the values in the specified row.
   - If the row index is out of bounds, an `out_of_range` exception is thrown.

8. **Method to Get a Specific Column by Its Index (`Table::getColumn(int columnIdx) const`)**
   - This method retrieves the values from the specified column (`columnIdx`).
   - It iterates over all rows, collecting the values from the specified column, and returns them as a vector of integers.
   - If the column index is invalid, an `out_of_range` exception is thrown.

9. **Method to Get a Specific Row by Its Index (`Table::getRow(int rowIdx) const`)**
   - This method retrieves the entire row at the specified index `rowIdx`.
   - It checks if the index is valid, collects the row's values, and returns them as a vector of integers.
   - If the row index is invalid, an `out_of_range` exception is thrown.

10. **Method to Set a Specific Row at a Given Index (`Table::setRow(int rowIdx, const vector<int>& newRow)`)**
    - This method allows manually setting the values of a specific row at the specified index `rowIdx`.
    - It checks if the row index is valid and if the new row has the correct number of columns.
    - If the new row has a different number of columns from the table, an `invalid_argument` exception is thrown.
    - Once the checks pass, the row at the specified index is replaced with the new row.

Summary of Workflow:
--------------------
1. **Random Data Generation**: If the constructor with random data is used, rows are generated randomly and stored in an `unordered_set` to ensure uniqueness.
2. **Manual Data Initialization**: If the constructor with manual data is used, the provided 2D vector is stored as `tableData` after validation.
3. **Accessing Data**: Various methods like `getValue()`, `getRow()`, `getColumn()` allow access to the tableâ€™s data by row or column.
4. **Printing Data**: Methods like `printTable()` and `print_row()` allow printing specific or all rows of the table.
5. **Modifying Data**: The `setRow()` method allows setting a new row at a specific index.
6. **Exception Handling**: The code throws exceptions such as `out_of_range` and `invalid_argument` if invalid indices or data are provided.


----------------------------------------------------------
### Find_SETs.cpp file ###
----------------------------------------------------------
This code includes several functions that work with a `Table` object, and it is used to find all valid "SETs" from a table of data. It includes methods for counting specific elements, checking the validity of a "SET," sorting, and finding valid "SETs." 

1. **Function `count_elements`**
   - This function takes a vector of integers as input (e.g., a row or a column of the table) and counts the occurrences of three distinct values: `-1`, `0`, and `1`.
   - It initializes a vector `counts` with three zeros, where:
     - `counts[0]` holds the count of `-1`,
     - `counts[1]` holds the count of `0`, and
     - `counts[2]` holds the count of `1`.
   - It then iterates over the input vector, and for each element (`-1`, `0`, or `1`), it increments the appropriate count.
   - Finally, it returns the `counts` vector with the results.

2. **Function `is_valid_set`**
   - This function checks if three rows from the table form a valid "SET." A valid "SET" follows specific rules:
     - For each corresponding element in the three rows, the sum of the elements must be either `-3`, `0`, or `3`.
   - The function iterates through each element of the rows, sums the values, and returns `false` if any of the sums are not `-3`, `0`, or `3`. If all sums are valid, the function returns `true`, indicating the rows form a valid "SET."

3. **Function `add_valid_set`**
   - This function adds a valid "SET" combination to a list of valid sets and optionally prints the set.
   - It first checks if the combination of three rows (referenced by indices) forms a valid "SET" using the `is_valid_set` function.
   - If the combination is valid, it adds the combination (a vector of row indices) to the `validSets` list.
   - If the `print` flag is `true`, it prints the rows in the valid set using the `print_row` method of the `Table` class.

4. **Function `counting_sort`**
   - This function performs counting sort on a vector of pairs (`indexedColumn`), where each pair consists of an integer value (either `-1`, `0`, or `1`) and the corresponding row index.
   - First, it counts the occurrences of `-1`, `0`, and `1` in the `indexedColumn` using the `count_elements` function.
   - Then, based on these counts, it sorts the pairs, placing `-1` first, followed by `0`, and then `1`. 
   - It returns the sorted vector of pairs, which helps in efficiently finding valid "SETs" by ensuring the correct order of values (`-1`, `0`, `1`).

5. **Function `find_SETs`**
   - This function finds all valid "SETs" in the table by checking all possible combinations of rows.
   - First, it retrieves the first column of the table and counts the occurrences of `-1`, `0`, and `1` in this column using the `count_elements` function.
   - Then, it creates a vector of pairs (`indexedColumn`), where each pair consists of a value from the first column and its original index.
   - The `indexedColumn` is then sorted using the `counting_sort` function to ensure the rows are ordered by values `-1`, `0`, and `1`.
   - The function iterates through all pairs of rows `(i, j)` and calculates the sum of the values of rows `i` and `j` for each element.
   - Based on the sum of the pair, it determines the valid range for the third row (`k`) that completes the "SET."
   - It then checks the remaining rows `k` within this valid range and adds any valid "SETs" to the `validSets` list using the `add_valid_set` function.
   - If the `bool_version` flag is `true`, the function returns as soon as it finds the first valid "SET."
   - Finally, the function prints the total number of valid "SETs" found (if the `print` flag is `true`) and returns the list of valid sets.

Summary of Workflow:
--------------------
1. **Counting Elements**: The `count_elements` function counts occurrences of `-1`, `0`, and `1` in the input data (such as a row or column).
2. **Valid SET Check**: The `is_valid_set` function checks if three rows form a valid "SET" based on specific conditions for the sum of their corresponding elements.
3. **Adding Valid SETs**: The `add_valid_set` function adds a valid "SET" to the list and optionally prints it.
4. **Sorting**: The `counting_sort` function sorts a vector of pairs to organize rows by values `-1`, `0`, and `1`, which helps optimize the search for valid "SETs."
5. **Finding Valid SETs**: The `find_SETs` function finds all valid "SETs" by iterating over the rows and checking for valid combinations of three rows using the previously defined functions. It handles the sorting and checking efficiently by considering the sum of pairs of rows.

----------------------------------------------------------
### Write_txt.cpp ###
----------------------------------------------------------

This code defines a function `write_data` that saves information about the results of processing a set of matrices (tables) into a text file. It takes the number of "SETs" found in each table and the matrices themselves as inputs, and writes the following information into a file:

1. **Function `write_data`**:
   - **Input Parameters**:
     - `filename`: The name of the text file where the results will be saved.
     - `SETs_count`: A vector containing the number of "SETs" found in each table (matrix).
     - `matrices`: A vector of `Table` objects, each representing a matrix (table) to be saved.

2. **Writing to a File**:
   - The function begins by opening the specified file for writing using `ofstream file(filename);`. If the file cannot be opened, it prints an error message and returns.
   
3. **Extracting Matrix Parameters**:
   - It first extracts the following parameters from the matrices:
     - `N_tables`: The total number of tables (matrices).
     - `n_cards`: The number of cards (rows) in the first table.
     - `n_att`: The number of attributes (columns) in the first row of the first table.
   - These values are written to the file under the section `# Parameters`.

4. **Writing Number of SETs in Each Table**:
   - The function writes the number of SETs found in each table into the file, which is obtained from the `SETs_count` vector. This information is written under the section `# Number of SETs in each Table`.
   - Additionally, it counts how many of the tables have 0 SETs and writes this information.

5. **Computing and Writing Statistics**:
   - The function computes the average number of SETs found across all the tables. This is calculated by summing all the values in the `SETs_count` vector and dividing by the number of tables.
   - It then writes the following statistics:
     - The number of tables that have 0 SETs, along with the total number of tables.
     - The probability (percentage) of a table having no SETs.
     - The average number of SETs across all tables.

6. **Writing the Matrices**:
   - Finally, the function writes all the matrices to the file. Each matrix is printed row by row, with each number in a row separated by a space.
   - After each matrix, it inserts a blank line to separate it from the next matrix.

7. **Closing the File**:
   - Once all the data has been written, the file is closed, and a message is displayed on the console confirming that the results have been saved to the specified file.

### Workflow:
1. **Open the File**: The file is opened for writing. If it fails to open, an error message is shown.
2. **Extract Parameters**: The number of cards (rows), attributes (columns), and tables is written to the file under `# Parameters`.
3. **Write Number of SETs**: The function writes how many SETs were found in each table.
4. **Write Statistics**: It calculates and writes the number of tables with 0 SETs, the probability of no SETs, and the average number of SETs.
5. **Write Matrices**: The matrices are written to the file with rows separated by spaces.
6. **Close the File**: After writing all data, the file is closed, and a confirmation message is shown on the console.


### Key Points:
- **Error Handling**: If the file cannot be opened, an error message is printed.
- **Statistics**: The function calculates useful statistics about the SETs (e.g., the average number, probability of no SETs).
- **File Structure**: The output file contains a clear structure with sections for parameters, SETs count, statistics, and the actual matrices.

----------------------------------------------------------
### Find_SETs_brute ###
----------------------------------------------------------

This code defines the function `brute_force_find_SETs` which is used to find all valid combinations of 3 rows in a given table that satisfy a certain "SET" condition. A "SET" is a special condition, and for this function, it is assumed that `is_valid_set()` checks whether three given rows form a valid SET.

Here's a breakdown of what the function does:

1. **Function Parameters:**
   - **Table table**: The function receives an object of the `Table` class, which contains a set of data. The function operates on the rows of this table to identify valid sets.
   - **bool print**: This flag determines whether the function should print details about the valid sets it finds. If set to `true`, the function will print the details of each valid set it discovers.
   - **bool bool_version**: This flag determines whether the function should stop searching for valid sets once it finds the first one. If set to `true`, the function will return immediately after finding a valid set.

2. **Getting the Table Data:**
   - **firstColumn**: The function retrieves the first column of the table by calling `table.getColumn(0)`. This column is used to determine the number of rows in the table (`numRows`).
   - **numRows**: This variable stores the number of rows in the table by checking the size of the `firstColumn`.

3. **Looping through Combinations of Rows:**
   - The function then uses three nested `for` loops to iterate through all possible combinations of three distinct rows in the table. The outermost loop (`i`) selects the first row, the second loop (`j`) selects the second row, and the innermost loop (`k`) selects the third row.
   
   For example, if there are 5 rows in the table, it will check the combinations: (0,1,2), (0,1,3), (0,1,4), (0,2,3), (0,2,4), and so on.

4. **Checking if the Rows Form a Valid Set:**
   - **Row Extraction**: Inside the nested loops, the function extracts the rows `i`, `j`, and `k` using the `table.getRow()` method. These rows are checked to see if they form a valid "SET."
   - **SET Validation**: The function calls the `is_valid_set()` function, passing the three rows as arguments. This function checks if the three rows satisfy the SET condition. If the condition is met, the combination of rows is considered a valid set.

5. **Storing and Printing Valid Sets:**
   - **Storing**: If a valid set is found, the row indices (i, j, k) are added to the `validSets` vector. This vector keeps track of all valid sets found.
   - **Printing**: If the `print` flag is `true`, the function prints the details of the valid set, including the index and content of the three rows that form the SET. The `table.print_row()` method is used to print the rows.

6. **Early Exit (Optional):**
   - If the `bool_version` flag is set to `true`, the function immediately returns the `validSets` vector once the first valid set is found. This is useful if you only need to find one valid set and do not need to continue searching.

7. **Final Output:**
   - **Final Print**: If `print` is `true`, the function prints the total number of valid sets that were found by brute force.
   - **Returning Valid Sets**: The function returns the `validSets` vector, which contains all the valid sets (if `bool_version` was false, meaning it continued searching for all valid sets).

Summary of Workflow:
--------------------
1. The function starts by looping through all possible combinations of 3 rows in the table.
2. For each combination of rows, it checks whether they satisfy the SET condition using `is_valid_set()`.
3. If a valid set is found, the indices of the rows are stored in `validSets`.
4. If `print` is true, the function prints the details of each valid set.
5. If `bool_version` is true, the function exits after finding the first valid set.
6. Finally, the function returns the vector `validSets`, containing all the valid sets that were found.

