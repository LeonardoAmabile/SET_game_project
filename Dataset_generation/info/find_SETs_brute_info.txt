----------------------------------------------------------
### Find_SETs_brute ###
----------------------------------------------------------

This code defines the function `brute_force_find_SETs` which is used to find all valid combinations of 3 rows in a given table that satisfy a certain "SET" condition. A "SET" is a special condition, and for this function, it is assumed that `is_valid_set()` checks whether three given rows form a valid SET.

Here's a breakdown of what the function does:

1. **Function Parameters:**
   - **Table table**: The function receives an object of the `Table` class, which contains a set of data. The function operates on the rows of this table to identify valid sets.
   - **bool print**: This flag determines whether the function should print details about the valid sets it finds. If set to `true`, the function will print the details of each valid set it discovers.
   - **bool bool_version**: This flag determines whether the function should stop searching for valid sets once it finds the first one. If set to `true`, the function will return immediately after finding a valid set.

2. **Getting the Table Data:**
   - **firstColumn**: The function retrieves the first column of the table by calling `table.getColumn(0)`. This column is used to determine the number of rows in the table (`numRows`).
   - **numRows**: This variable stores the number of rows in the table by checking the size of the `firstColumn`.

3. **Looping through Combinations of Rows:**
   - The function then uses three nested `for` loops to iterate through all possible combinations of three distinct rows in the table. The outermost loop (`i`) selects the first row, the second loop (`j`) selects the second row, and the innermost loop (`k`) selects the third row.
   
   For example, if there are 5 rows in the table, it will check the combinations: (0,1,2), (0,1,3), (0,1,4), (0,2,3), (0,2,4), and so on.

4. **Checking if the Rows Form a Valid Set:**
   - **Row Extraction**: Inside the nested loops, the function extracts the rows `i`, `j`, and `k` using the `table.getRow()` method. These rows are checked to see if they form a valid "SET."
   - **SET Validation**: The function calls the `is_valid_set()` function, passing the three rows as arguments. This function checks if the three rows satisfy the SET condition. If the condition is met, the combination of rows is considered a valid set.

5. **Storing and Printing Valid Sets:**
   - **Storing**: If a valid set is found, the row indices (i, j, k) are added to the `validSets` vector. This vector keeps track of all valid sets found.
   - **Printing**: If the `print` flag is `true`, the function prints the details of the valid set, including the index and content of the three rows that form the SET. The `table.print_row()` method is used to print the rows.

6. **Early Exit (Optional):**
   - If the `bool_version` flag is set to `true`, the function immediately returns the `validSets` vector once the first valid set is found. This is useful if you only need to find one valid set and do not need to continue searching.

7. **Final Output:**
   - **Final Print**: If `print` is `true`, the function prints the total number of valid sets that were found by brute force.
   - **Returning Valid Sets**: The function returns the `validSets` vector, which contains all the valid sets (if `bool_version` was false, meaning it continued searching for all valid sets).

Summary of Workflow:
--------------------
1. The function starts by looping through all possible combinations of 3 rows in the table.
2. For each combination of rows, it checks whether they satisfy the SET condition using `is_valid_set()`.
3. If a valid set is found, the indices of the rows are stored in `validSets`.
4. If `print` is true, the function prints the details of each valid set.
5. If `bool_version` is true, the function exits after finding the first valid set.
6. Finally, the function returns the vector `validSets`, containing all the valid sets that were found.

